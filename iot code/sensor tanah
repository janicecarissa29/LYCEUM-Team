#include <WiFi.h>
#include <Firebase_ESP_Client.h>
#include <time.h>

// === CONFIGURATION ===
#define WIFI_SSID "Modal Dong"
#define WIFI_PASSWORD "namapapale"

// Firebase configuration
#define FIREBASE_HOST "lyceum-87240-default-rtdb.asia-southeast1.firebasedatabase.app"
#define FIREBASE_AUTH "lTBd8MUjcaXLuZ60slnTGQLh9v0jMJWsY2Q9uNjZ" 

#define SOIL_SENSOR_PIN 4
const unsigned long SEND_INTERVAL = 10000; // 10 seconds

// === GLOBALS ===
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

unsigned long sendDataPrevMillis = 0;

// NTP for WIB (Western Indonesian Time) - UTC+7
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 7 * 3600;  // +7 hours for WIB
const int daylightOffset_sec = 0;

// === FUNCTION DECLARATIONS ===
void connectToWiFi();
String getWIBDateTime();
String getWIBTimestamp();

// === SETUP ===
void setup() {
  Serial.begin(115200);
  delay(500);
  Serial.println("\n\n=== FL69 Soil Sensor → Firebase (WIB Time) ===");

  // Initialize sensor pin
  pinMode(SOIL_SENSOR_PIN, INPUT);
  
  connectToWiFi();

  // Sync time for WIB
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  Serial.println("Syncing time for WIB (UTC+7)...");
  
  // Wait for time sync
  time_t now = time(nullptr);
  while (now < 1000000000) {
    delay(1000);
    Serial.print(".");
    now = time(nullptr);
  }
  Serial.println("\n✅ Time synced for WIB.");
  Serial.print("Current WIB time: ");
  Serial.println(getWIBDateTime());

  // Firebase setup
  config.host = FIREBASE_HOST;
  config.signer.tokens.legacy_token = FIREBASE_AUTH;

  Serial.println("Connecting to Firebase...");
  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  
  // Set larger buffer size for stability
  fbdo.setBSSLBufferSize(4096, 1024);
  fbdo.setResponseSize(2048);
  
  Serial.println("✅ Firebase ready.");
}

// === LOOP ===
void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    connectToWiFi();
  }

  if (Firebase.ready() && millis() - sendDataPrevMillis > SEND_INTERVAL) {
    sendDataPrevMillis = millis();

    // Read sensor multiple times for stability
    int raw = 0;
    for(int i = 0; i < 5; i++) {
      raw += analogRead(SOIL_SENSOR_PIN);
      delay(10);
    }
    raw = raw / 5; // Average reading
    
    // Convert to percentage (adjust mapping based on your sensor calibration)
    int moisture = map(raw, 0, 4095, 100, 0); 
    moisture = constrain(moisture, 0, 100);

    // Get WIB time
    String wibDateTime = getWIBDateTime();
    String wibTimestamp = getWIBTimestamp();
    time_t epochTime = time(nullptr);

    Serial.println("=== SENSOR READING ===");
    Serial.print("Raw Value: ");
    Serial.println(raw);
    Serial.print("Moisture Level: ");
    Serial.print(moisture);
    Serial.println("%");
    Serial.print("WIB Time: ");
    Serial.println(wibDateTime);
    Serial.println("======================");

    // Build path with readable date format for easier querying
    String path = "/soil_moisture_readings/" + wibTimestamp;

    // Create JSON object with all data
    FirebaseJson json;
    json.set("moisture_level", moisture);      // Easy to read in Firebase
    json.set("moisture_percentage", moisture); // For compatibility
    json.set("raw_value", raw);
    json.set("wib_datetime", wibDateTime);     // Human readable WIB time
    json.set("wib_timestamp", wibTimestamp);   // Sortable timestamp
    json.set("epoch_time", (int)epochTime);    // Standard timestamp
    json.set("device_id", "ESP32-S3_FL69");
    json.set("sensor_pin", SOIL_SENSOR_PIN);
    
    // Add soil condition based on moisture level
    String soilCondition = "Unknown";
    if (moisture < 20) {
      soilCondition = "Sangat Kering";
    } else if (moisture < 40) {
      soilCondition = "Kering";
    } else if (moisture < 60) {
      soilCondition = "Lembab";
    } else if (moisture < 80) {
      soilCondition = "Basah";
    } else {
      soilCondition = "Sangat Basah";
    }
    json.set("soil_condition", soilCondition);

    // Send to Firebase
    Serial.print("Uploading to Firebase path: ");
    Serial.println(path);
    
    if (Firebase.RTDB.setJSON(&fbdo, path.c_str(), &json)) {
      Serial.println("✅ Data sent to Firebase successfully!");
      
      // Also update a "latest" node for easy access to current reading
      Firebase.RTDB.setJSON(&fbdo, "/soil_moisture_latest/current", &json);
      Serial.println("✅ Latest reading updated!");
      
    } else {
      Serial.print("❌ Upload failed: ");
      Serial.println(fbdo.errorReason());
      Serial.print("Error code: ");
      Serial.println(fbdo.httpCode());
    }
  }

  delay(1000);
}

// === GET WIB DATE TIME ===
String getWIBDateTime() {
  struct tm timeinfo;
  if(!getLocalTime(&timeinfo)){
    return "Time not available";
  }
  
  char timeString[64];
  strftime(timeString, sizeof(timeString), "%Y-%m-%d %H:%M:%S WIB", &timeinfo);
  return String(timeString);
}

// === GET WIB TIMESTAMP (for path) ===
String getWIBTimestamp() {
  struct tm timeinfo;
  if(!getLocalTime(&timeinfo)){
    return String(millis()); // Fallback to millis if time not available
  }
  
  char timeString[64];
  strftime(timeString, sizeof(timeString), "%Y%m%d_%H%M%S", &timeinfo);
  return String(timeString);
}

// === WiFi CONNECT ===
void connectToWiFi() {
  Serial.println("Connecting to WiFi...");
  WiFi.disconnect(true);
  delay(1000);
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  Serial.print("Connecting to WiFi");
  int count = 0;
  while (WiFi.status() != WL_CONNECTED && count < 30) {
    delay(500);
    Serial.print(".");
    count++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n✅ WiFi Connected. IP: " + WiFi.localIP().toString());
  } else {
    Serial.println("\n❌ WiFi failed. Restarting...");
    ESP.restart();
  }
}